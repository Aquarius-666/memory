一、硬件原理和分页管理

1.CPU寻址内存，虚拟地址、物理地址

​     在一个CPU眼里，访问一个东西有两种可能，一个是内存空间，一个是IO空间，IO空间是X86处理器特有的一个东西，因为x86处理器在访问一些外设的时候是通过in/out这样的指令的，而不是通过指针的方式，在RISC处理器中，一般没有IO空间，RISC处理器中，<u>内存空间一般分为内存和寄存器</u>，比如一般嵌入式处理器的gpio控制器，usb控制器,i2c控制器里面的寄存器都可以通过指针来访问，但是这些控制器连接的外设的寄存器，跟内存空间没有任何关系，跟IO空间也没有关系。<u>内存空间和IO空间都是站在CPU的角度来看的。</u>

​	对于有MMU的处理器，CPU访问内存是先发一个虚拟地址，用MMU把这个虚拟地址转化为物理地址。内存里有一个页表，页表的基地址会传到MMU的一个寄存器里面，每切换一个进程，进程的页表都不一样，传给MMU的页表基地址也不一样。<u>一旦开启了MMU，CPU只知道虚拟地址，不知道物理地址。</u>地址转换是硬件MMU去做的。

​	例如，CPU访问虚拟地址0x1234560，560是页面偏移，CPU就去查页表目录，找到0x1234地址处存放的对应的物理地址，比如说是1M，那么CPU最终访问的物理地址就是1M+0x560这个地址。

​	物理地址在linux中就是定义成一个整数：

```c
[include/linux/types.h]
#ifdef CONFIG_PHYS_ADDR_T_64BIT
typedef u64 phys_addr_t;
#else
typedef u32 phys_addr_t;
#endif

typedef phys_addr_t resource_size_t;


```





2.MMU以及RWX权限、kernel和user模式权限

​	对于一个32位的处理器，页表的每一项都是32个bit，描述地址的时候使用了高20bit，剩下的低12bit用来描述: 1）RWX权限: 在Linux里面，每一个东西都有不同的权限，例如代码段，Linux只给他R+X的权限，如果用一个指针去写代码段，页表里并没有标明它有写权限，所以一旦你去写，MMU立马给CPU发中断，这个中断就是```page fault```，CPU收到这个```page fault```之后，马上就查产生```page fault```的原因，发现有程序再写代码段，于是就发出一个段错误信号，杀掉这个应用程序。2）kernel/User+kernel权限：在Linux里面，内核和应用是分开的，对于32位的处理器来说，0~3G是用户空间，标记为应用和内核都可访问，3~4G是内核空间，所以标记为只有内核可以访问，一旦应用去访问了，也会发出段错误的信号，杀掉这个应用程序。



​    熔断漏洞meltdown指什么？

就是用户态可以拿到内核态的数据。基本原理如下：

一个应用程序：a[256]; //a每个都比较大，cacheline...

​				           c = *k; //k是一个内核空间的地址

​							按理说运行到这里会报段错误，但是由于处理器把错误上报也需要时间，
​							所以可能执行了后面的指令，但是这里也读不到*k的内容，也不知道c的值
​							是什么，接下来把a[256]里面的每个成员都读一遍：
​								for(i=0;i < 256; i++)
​								{
​										开始时间	
​										读一下a[i]
​										结束时间
​								}
​							delta = 结束-开始；这个时间是不一样的，255个成员都很慢，只有第C个
​							成员很快，因为只有第C个成员cache命中，这样就不会去访问memory，
​							速度就快。

通过时间的旁路攻击原理(Side Channel Attacks,SCA).

3.内存的zone：DMA、NORMAL和HIGHMEM（物理内存）

​	 <u>对于一个64位的处理器而言，没有低端高端内存的概念。</u>，如果是32位处理器，内存条很小，可以直接线性映射，那也不存在什么高端内存。

​     在32位计算机中，CPU不能直接访问所有的物理地址，例如linux内核空间3~4G，无法将所有的物理内存线性映射，所以只能将0~896M的内存空间进行**线性映射**（这个896M也不是固定的，可以改），上电就映射好的，这一段可称为```ZONE_NORMAL```,内核中有```virt_to_phys```,```phys_to_virt```这两个宏进行物理地址和虚拟地址的转换，但是这都是简单的线性偏移，而且只针对```ZONE_NORMAL```  区域，CPU可直接访问。其他无法线性映射的内存区域就叫```ZONE_HIGH```,比如896M以上的物理内存要先进行映射才能访问。

​	```ZONE_DMA```也不一定存在，它存在的原因就是因为硬件有缺陷。内存被访问有两种方式，一种是CPU通过MMU进行虚实转换访问，另一种就是DMA（gpu什么都可理解为DMA），大部分DMA没有MMU，一些厉害的DMA也可能自带MMU。 DMA访问内存时是直接访问内存的，不需要经过CPU，但是一些DMA有缺陷，对于X86的**ISA**总线而言，它只能访问16M以下的内存，所以DMA连接的外设，如果申请内存，那只能申请16M以下的，申请16M以上的也没用，所以针对这种问题，linux就分出一个```ZONE_DMA```,```ZONE_DMA```这个区域的内存，谁都可以申请，只是说有**缺陷的DMA申请的内存绝对是来自```ZONE_DMA```**,因为它会带一个标记```GFP_DMA```去申请 。如果DMA没有缺陷，所有内存都可以访问到，那随便申请一个内存就可以作为DMA内存。所以<u>DMA申请的内存不一定来自于```ZONE_DMA```, ```ZONE_DMA```的内存也不一定用于DMA。</u> 

64位处理器中，将内存的DMA ZONE分为```ZONE_DMA```和```ZONE_DMA32```,是为了兼容以前的32位处理器的ISA。

<u>DMA最大的好处就是可以让CPU做别的事情，不会使外设变得快，快慢是由总线频率及访问频率决定的，跟DMA没有关系</u>。

![1594346769551](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1594346769551.png)



4.Linux内存管理Buddy算法

​	 buddy算法直面物理内存，空闲页面按照2的n次方管理，1页空闲的放在一张链表，2页空闲的放在一张链表，4页空闲的放在一张链表，...... ，不停地进行拆分合并。例如ZONE_NORMAL中有16页空闲，那么这16页一开始肯定在2的4次方链表中，如果这个时候要申请1页，那么剩下的15页拆分成8页、4页、2页、1页。在linux中可以查看空闲内存的分布情况，可以看到各个zone里面1页空闲，2页空闲，......，的还有多少个。

![1594352119426](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1594352119426.png)

buddy算法不停的在申请释放的时候，可能到了最后会出现内存很大，但是连续内存很小的情况。例如绝大多数DMA都不带MMU，要申请连续物理内存，如果这个时候没有足够的连续物理内存怎么办？早期的时候，采用预留内存的方法，后期采用CMA。

5.连续内存分配器CMA

也就是预留一块内存，平常给应用程序用，一旦要申请连续物理地址，就把应用程序用的这些内存空间挪到其他地方，空出预留的这一块连续物理内存供使用。对于应用程序来说，看到的都是虚拟地址，所以物理地址在哪无所谓。

linux中关于CMA的文档可以参考```Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt ```。

